from itertools import combinations
from mathutil import product


def prime_under(ceiling):
    primes = []
    global primality
    primality = [True] * ceiling
    primality[0], primality[1] = False, False
    for (i, isPrime) in enumerate(primality):
        if isPrime:
            primes.append(i)
            for j in range(i * i, ceiling, i):
                primality[j] = False
    return primes


def check_n(num, factors):
    num_of_fac = len(factors)
    if not primality[num + 1]:
        return False
    for i in range(1, num_of_fac//2+1):
        for comb in combinations(range(num_of_fac), i):
            part1 = product(factors[j] for j in comb)
            if not primality[part1 + num//part1]:
                return False
    return True


# slower
def check(num):
    for i in range(1, int(num ** 0.5) + 1):
        if num % i == 0:
            if not primality[i + num // i]:
                return False
    return True

primality = []


def main():
    N = 10 ** 8
    prime_gen = [1, 2]  # having less than 2 factors
    primes = prime_under(N)
    max_index = len(primes)
    print("Prime generated by", time() - starting_time, "seconds")

    # 2
    for i in range(1, max_index):
        num = 2 * primes[i]
        if num > N:
            break
        if check_n(num, [2, primes[i]]):
            prime_gen.append(num)
    print("2", time()-starting_time)

    # 3
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            num = current_i * primes[j]
            if num > N:
                break
            if check_n(num, [2, primes[i], primes[j]]):
                prime_gen.append(num)
    print("3", time()-starting_time)

    # 4
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            current_j = current_i * primes[j]
            if current_j > N:
                break
            for k in range(j + 1, max_index):
                num = current_j * primes[k]
                if num > N:
                    break
                if check_n(num, [2, primes[i], primes[j], primes[k]]):
                    prime_gen.append(num)
    print("4", time()-starting_time)

    # 5
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            current_j = current_i * primes[j]
            if current_j > N:
                break
            for k in range(j + 1, max_index):
                current_k = current_j * primes[k]
                if current_k > N:
                    break
                for l in range(k + 1, max_index):
                    num = current_k * primes[l]
                    if num > N:
                        break
                    if check_n(num, [2, primes[i], primes[j], primes[k], primes[l]]):
                        prime_gen.append(num)
    print("5", time()-starting_time)

    # 6
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            current_j = current_i * primes[j]
            if current_j > N:
                break
            for k in range(j + 1, max_index):
                current_k = current_j * primes[k]
                if current_k > N:
                    break
                for l in range(k + 1, max_index):
                    current_l = current_k * primes[l]
                    if current_l > N:
                        break
                    for m in range(l + 1, max_index):
                        num = current_l * primes[m]
                        if num > N:
                            break
                        if check_n(num, [2, primes[i], primes[j], primes[k], primes[l], primes[m]]):
                            prime_gen.append(num)
    print("6", time()-starting_time)

    # 7
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            current_j = current_i * primes[j]
            if current_j > N:
                break
            for k in range(j + 1, max_index):
                current_k = current_j * primes[k]
                if current_k > N:
                    break
                for l in range(k + 1, max_index):
                    current_l = current_k * primes[l]
                    if current_l > N:
                        break
                    for m in range(l + 1, max_index):
                        current_m = current_l * primes[m]
                        if current_m > N:
                            break
                        for n in range(m + 1, max_index):
                            num = current_m * primes[n]
                            if num > N:
                                break
                            if check_n(num, [2, primes[i], primes[j], primes[k], primes[l], primes[m], primes[n]]):
                                prime_gen.append(num)
    print("7", time()-starting_time)

    # 8
    for i in range(1, max_index):
        current_i = 2 * primes[i]
        if current_i > N:
            break
        for j in range(i + 1, max_index):
            current_j = current_i * primes[j]
            if current_j > N:
                break
            for k in range(j + 1, max_index):
                current_k = current_j * primes[k]
                if current_k > N:
                    break
                for l in range(k + 1, max_index):
                    current_l = current_k * primes[l]
                    if current_l > N:
                        break
                    for m in range(l + 1, max_index):
                        current_m = current_l * primes[m]
                        if current_m > N:
                            break
                        for n in range(m + 1, max_index):
                            current_n = current_m * primes[n]
                            if current_n > N:
                                break
                            for o in range(n + 1, max_index):
                                num = current_n * primes[o]
                                if num > N:
                                    break
                                if check_n(num, [2, primes[i], primes[j], primes[k], primes[l], primes[m], primes[n], primes[o]]):
                                    prime_gen.append(num)
    print("8", time()-starting_time)

    # print(prime_gen)
    print(sum(prime_gen))


if __name__ == '__main__':
    from time import time

    starting_time = time()
    main()
    print("Time elapsed:", time() - starting_time, "seconds")
